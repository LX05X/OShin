name: Android CI

# 定义工作流的触发条件 - 修改为手动触发
on:
  workflow_dispatch: # 手动触发工作流
    # 可选：添加输入参数
    inputs:
      build_type:
        description: '构建类型'
        required: true
        default: 'release'
        type: choice
        options:
          - release
          - debug
      tag_name:
        description: 'Release 标签名称（可选，留空自动生成）'
        required: false
        type: string

# 为工作流中的所有作业设置默认权限。
permissions:
  contents: write # 允许写入内容，例如创建 GitHub Release。
  actions: write  # 允许操作 Actions，例如取消工作流。
  packages: write # 允许写入 GitHub Packages。

# 定义工作流中的作业
jobs:
  build-and-release: # 作业的唯一ID

    runs-on: ubuntu-latest # 指定作业运行在最新版的 Ubuntu 虚拟环境中。

    steps:
      # 第 1 步：检出代码
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 获取所有历史提交记录，以便 `git rev-list` 可以正确计算版本号。

      # 第 2 步：设置 JDK 环境
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'        # 指定 Java 版本为 21。
          distribution: 'temurin'   # 使用 Eclipse Temurin 发行版。
          cache: gradle             # 启用 Gradle 依赖项的缓存，以加快后续构建速度。

      # 第 3 步：设置签名密钥库
      - name: Setup Keystore
        run: echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 --decode > keystore.jks

      # 第 4 步：构建并签名应用
      - name: Build with Gradle
        run: |
          chmod +x gradlew # 授予 gradlew 脚本执行权限。
          
          # 根据输入的构建类型选择任务
          if [ "${{ github.event.inputs.build_type }}" = "debug" ]; then
            echo "构建 Debug 版本"
            ./gradlew assembleDebug
          else
            echo "构建 Release 版本"
            ./gradlew assembleRelease
          fi
        env:
          KEYSTORE_PATH: "../keystore.jks"
          KEYSTORE_PASSWORD: ${{ secrets.KEY_STORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}

      # 第 5 步：准备构建产物信息 - 修复APK查找逻辑
      - name: Prepare Artifacts, Extract Version String, and Generate Summary
        id: artifacts
        run: |
            echo "=== 开始查找APK文件 ==="
            
            # 根据构建类型选择目录
            if [ "${{ github.event.inputs.build_type }}" = "debug" ]; then
              apk_dir="app/build/outputs/apk/debug"
              echo "查找Debug APK在目录: $apk_dir"
              
              # 列出目录内容
              echo "目录内容:"
              find "$apk_dir" -type f -name "*.apk" | while read file; do
                echo "找到文件: $file"
              done
              
              # 查找第一个.apk文件
              apk_file_v8a=$(find "$apk_dir" -type f -name "*.apk" | head -1)
              echo "选择的APK文件: $apk_file_v8a"
            else
              apk_dir="app/build/outputs/apk/release"
              echo "查找Release APK在目录: $apk_dir"
              
              # 列出目录内容
              echo "目录内容:"
              find "$apk_dir" -type f -name "*.apk" | while read file; do
                echo "找到文件: $file"
              done
              
              # 尝试多种可能的文件名模式
              apk_file_v8a=$(find "$apk_dir" -type f -name "OShin_arm64-v8a_v*.apk" | head -1)
              if [ -z "$apk_file_v8a" ]; then
                echo "未找到 OShin_arm64-v8a_v*.apk，尝试其他模式..."
                apk_file_v8a=$(find "$apk_dir" -type f -name "*arm64-v8a*.apk" | head -1)
              fi
              if [ -z "$apk_file_v8a" ]; then
                echo "未找到 *arm64-v8a*.apk，尝试第一个.apk文件..."
                apk_file_v8a=$(find "$apk_dir" -type f -name "*.apk" | head -1)
              fi
              echo "选择的APK文件: $apk_file_v8a"
            fi
            
            # 检查是否找到APK文件
            if [ -z "$apk_file_v8a" ]; then
              echo "::error::APK not found in $apk_dir!"
              echo "尝试列出所有可能的APK位置..."
              find app/build -name "*.apk" -type f
              exit 1
            fi
            
            # 确保APK文件存在
            if [ ! -f "$apk_file_v8a" ]; then
              echo "::error::APK file does not exist: $apk_file_v8a"
              exit 1
            fi
            
            echo "APK_FILE_V8A=$apk_file_v8a" >> $GITHUB_ENV
            echo "找到APK文件: $apk_file_v8a"
          
            # 如果用户提供了自定义标签名，使用它
            if [ -n "${{ github.event.inputs.tag_name }}" ]; then
              tag_name="${{ github.event.inputs.tag_name }}"
              echo "Using custom tag name: $tag_name"
              echo "tag_name=$tag_name" >> $GITHUB_OUTPUT
              echo "release_name=$tag_name" >> $GITHUB_OUTPUT
            else
              # 自动生成版本信息
              if [ "${{ github.event.inputs.build_type }}" = "debug" ]; then
                # Debug 版本使用时间戳
                timestamp=$(date +"%Y%m%d_%H%M%S")
                tag_name="debug-$timestamp"
                echo "Generated debug tag name: $tag_name"
                echo "tag_name=$tag_name" >> $GITHUB_OUTPUT
                echo "release_name=$tag_name" >> $GITHUB_OUTPUT
              else
                # Release 版本提取版本号
                apk_filename=$(basename "$apk_file_v8a")
                echo "Extracted filename: $apk_filename"
              
                # 尝试从文件名中提取版本号（多种模式）
                version_string="v1.0.0" # 默认版本
                
                # 模式1: OShin_arm64-v8a_v1.0.0.apk
                if [[ "$apk_filename" =~ OShin_arm64-v8a_(v.*)\.apk ]]; then
                  version_string="${BASH_REMATCH[1]}"
                # 模式2: app-arm64-v8a-release.apk 或类似格式
                elif [[ "$apk_filename" =~ app.*\.apk ]]; then
                  version_string="release-$(date +"%Y%m%d_%H%M%S")"
                fi
                
                echo "Extracted version string: $version_string"
              
                # 设置 tag_name 输出为提取的版本字符串
                echo "tag_name=$version_string" >> $GITHUB_OUTPUT
                echo "release_name=$version_string" >> $GITHUB_OUTPUT
              fi
            fi
          
            # 计算 SHA
            sha_v8a=$(sha256sum "$apk_file_v8a" | awk '{print $1}')
            echo "sha_v8a=$sha_v8a" >> $GITHUB_OUTPUT
            echo "SHA256: $sha_v8a"
          
            # 生成摘要
            {
              echo "### OShin Build Success :rocket:"
              echo ""
              echo "**Build Type:** ${{ github.event.inputs.build_type }}"
              echo "**APK File:** $(basename "$apk_file_v8a")"
              echo "**APK Path:** $apk_file_v8a"
              echo ""
              echo "| Architecture | SHA256 Hash |"
              echo "|:---|:---|"
              echo "| arm64-v8a | \`$sha_v8a\` |"
              echo ""
              echo "**Triggered by:** ${{ github.actor }}"
              echo ""
              echo "**Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})"
            } >> $GITHUB_STEP_SUMMARY
            
            echo "=== APK准备完成 ==="

      # 第 6 步：上传构建产物
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: OShin-${{ github.event.inputs.build_type }}-Build-${{ github.sha }}
          path: |
            app/build/outputs/apk/debug/
            app/build/outputs/apk/release/

      # 第 7 步：创建 Release（仅对 release 类型构建）
      - name: Create Release and Upload Asset to OShin-Builds
        if: github.event.inputs.build_type == 'release'
        uses: softprops/action-gh-release@v1
        with:
          repository: suqi8/OShin-Builds
          token: ${{ secrets.PUSH_TOKEN }}
          # 使用提取的版本字符串作为 tag_name
          tag_name: ${{ steps.artifacts.outputs.tag_name }}
          # 使用提取的版本字符串作为 Release 的 Name
          name: ${{ steps.artifacts.outputs.release_name }}
          body: |
            # OShin Release Build
            
            ## Build Info
            - **Build Type:** ${{ github.event.inputs.build_type }}
            - **Triggered by:** ${{ github.actor }}
            - **Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
            - **Commit Message:** ${{ github.event.head_commit.message }}
            
            ## Checksums
            - **arm64-v8a:** `${{ steps.artifacts.outputs.sha_v8a }}`
            
            *This is an automated build from CI/CD pipeline.*
          prerelease: false
          files: ${{ env.APK_FILE_V8A }}
